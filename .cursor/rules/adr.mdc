---
description: Follow Architecture Decision Records when changing architecture, persistence, or user-facing behavior
alwaysApply: true
---

# Architecture Decision Records (ADRs)

1. **Follow existing ADRs**: When changing architecture, persistence, or user-facing behavior, read the relevant documents in **docs/adr/** and align your implementation with the decisions recorded there.

2. **Consult the index**: Before implementing features that touch those areas, check **docs/adr/README.md** for the list of ADRs and open any that apply.

3. **Adding a new decision**: When making a new architectural or behavioral decision, create a new ADR under docs/adr/ using the template (0000-template.md), use the next number in sequence (e.g. 0002), and update the index in docs/adr/README.md. If the decision affects how agents should work, update this rule or .github/copilot-instructions.md as needed.

4. **Conflicts**: If a requested change would conflict with an accepted ADR, either update the ADR (e.g. supersede it with a new one) or align the implementation with the ADR; do not silently contradict documented decisions.

5. **NuGet packages**: When adding or changing NuGet dependencies, follow [ADR-0013](docs/adr/0013-secure-nuget-packages.md) — avoid insecure or obsolete packages.

6. **New visualizers**: Create new visualizer content as text layer renderers (inherit TextLayerRendererBase, implement ITextLayerRenderer&lt;TState&gt;) in TextLayersVisualizer, not as standalone IVisualizer implementations. See [ADR-0014](docs/adr/0014-visualizers-as-layers.md).

7. **Layer settings**: TextLayerSettings has common props plus Custom (JSON); layer-specific settings go in *Settings.cs next to the layer; use `GetCustom<TSettings>()` in Draw. See [ADR-0021](docs/adr/0021-textlayer-settings-common-custom.md).

8. **Presets**: TextLayers configurations are stored as Presets in `presets/*.json` (one file per preset). V cycles presets; S modal: R rename, N new preset. See [ADR-0019](docs/adr/0019-preset-textlayers-configuration.md), [ADR-0022](docs/adr/0022-presets-in-own-files.md).

9. **Layer settings editing**: The S settings modal is the canonical UI for editing layer settings (common properties and Custom). When adding layer-editing capabilities, implement them in the S modal, not in HandleKey or other ad-hoc places. See [ADR-0023](docs/adr/0023-settings-modal-layer-editing.md).

10. **Layer settings discovery**: Layer settings are discovered via reflection. New settings: add *Settings.cs with properties; use [SettingRange], [SettingChoices], [Setting] where needed; register in LayerSettingsReflection.s_customSettingsRegistry. See [ADR-0021](docs/adr/0021-textlayer-settings-common-custom.md), [ADR-0025](docs/adr/0025-reflection-based-layer-settings.md).

11. **C# documentation and file organization**: Non-empty XML summaries for classes and interfaces; prefer one file per class. See [ADR-0016](docs/adr/0016-csharp-documentation-and-file-organization.md).

12. **UI text overflow**: Use IScrollingTextViewport (from IScrollingTextViewportFactory.CreateViewport()) for dynamic text (toolbar, status lines) that may exceed width; use ellipsis truncation (TruncateWithEllipsis) for static text (titles, labels). Wrap strings in PlainText or AnsiText; use AnsiText when content may contain ANSI escape sequences. See [ADR-0020](docs/adr/0020-ui-text-components-scrolling-and-ellipsis.md), [ADR-0032](docs/adr/0032-typed-display-text.md), [ADR-0037](docs/adr/0037-scrolling-text-viewport-injectable-service.md).

13. **Layer dependency injection**: Layers that need external services (e.g. INowPlayingProvider) receive them via constructor injection. Snapshot does not carry service-derived data. Layers are registered in the DI container (AddTextLayerRenderers); TextLayersVisualizer receives IEnumerable&lt;TextLayerRendererBase&gt;. See [ADR-0028](docs/adr/0028-layer-dependency-injection.md).

14. **Settings format changes**: Do not add migration logic for old settings. When schema changes cause incompatibility, backup the file with `{name}.{timestamp}.bak` and create new from defaults. See [ADR-0029](docs/adr/0029-no-settings-migration.md).

15. **Performance**: Console writes, polling, and timing must be performant. Follow [ADR-0030](docs/adr/0030-performance-priority.md) when adding console I/O, key polling, or frame-rate logic.

16. **Shows**: Preset collections for performance auto-cycling. Stored in `shows/*.json`; Tab switches Preset editor ↔ Show play; S in Show play opens Show edit modal. Duration per entry: Seconds or Beats. See [ADR-0031](docs/adr/0031-show-preset-collection.md).

17. **Display text types**: IScrollingTextViewport.Render, RenderWithLabel, and StaticTextViewport.TruncateToWidth, TruncateWithEllipsis accept IDisplayText. Use PlainText for unformatted strings, AnsiText when text may contain ANSI escape sequences. No implicit string conversion. See [ADR-0032](docs/adr/0032-typed-display-text.md).

18. **UI settings and palette**: Use existing components (e.g. IScrollingTextViewport) when possible. UI has configurable settings in appsettings: Title, TitleBarAppName, TitleBarPalette, UiSettings.Palette (Normal, Highlighted, Dimmed, Label, optional Background), DefaultScrollingSpeed. IScrollingTextViewport.RenderWithLabel uses label/text colors when provided. Layer numbers use UI palette. Do not add separators between UI viewports; label+value colors provide separation. See [ADR-0033](docs/adr/0033-ui-principles-and-configurable-settings.md), [ADR-0036](docs/adr/0036-title-bar-injectable-component.md).

19. **Viewport label hotkeys**: When a labeled viewport references a feature with a hotkey, show it in the label as "Label(K):" (e.g. "Preset(V):"). Use IScrollingTextViewport.FormatLabel or pass hotkey to RenderWithLabel. See [ADR-0034](docs/adr/0034-viewport-label-hotkey-hints.md).

20. **Modal dependency injection**: Modals (device selection, help, settings, show edit) are injectable services. Define an interface, implement with constructor-injected dependencies, register in ServiceConfiguration, inject into consumers. Show methods accept only runtime parameters (e.g. consoleLock, saveSettings). See [ADR-0035](docs/adr/0035-modal-dependency-injection.md).

21. **Title bar**: The header title bar is an injectable component (ITitleBarRenderer) that renders `{appName}/{mode}/{preset}/{layer}` in a cyberpunk style. UiSettings has TitleBarAppName and TitleBarPalette for customization. See [ADR-0036](docs/adr/0036-title-bar-injectable-component.md).

22. **Scrolling viewport**: Scrolling text (ping-pong) is an injectable service. IScrollingTextEngine (data) advances scroll state; IScrollingTextViewport (render) holds state, applies label/ANSI. Use IScrollingTextViewportFactory.CreateViewport() for each scroll region. Viewport auto-resets when content changes. See [ADR-0037](docs/adr/0037-scrolling-text-viewport-injectable-service.md).

23. **Header refresh timer**: Header (device, now-playing, BPM, volume) is refreshed by a 50ms PeriodicTimer independent of audio. Scrolling text in the header animates even when no audio is playing (e.g. WASAPI loopback). Use AnalysisEngine.RefreshHeaderIfNeeded() for header-only updates. See [ADR-0038](docs/adr/0038-header-refresh-independent-of-audio.md).

24. **Display width**: Use display width (terminal columns) for fitting text to viewport. Wide characters (emoji, CJK, fullwidth) occupy 2 columns. Use GetDisplayWidth, GetDisplaySubstring, PadToDisplayWidth, and DisplayWidth utility for column-based measurements. TruncateToWidth and TruncateWithEllipsis use display width. See [ADR-0039](docs/adr/0039-display-width-terminal-columns.md).

25. **Dependency injection**: Prefer constructor injection and DI registration for new components (services, UI, layers, modals). Deviate only when profiling shows DI or indirection harms performance on hot paths; document the rationale. Use singleton/scoped registrations for hot-path services. See [ADR-0040](docs/adr/0040-dependency-injection-preference.md).

26. **God object refactoring**: When refactoring ApplicationShell, AnalysisEngine, or SettingsModal, follow [ADR-0041](docs/adr/0041-god-object-refactoring-strategy.md) and the task list in [docs/refactoring/god-object-plan.md](docs/refactoring/god-object-plan.md). Mark tasks `[x]` when implemented.

27. **UI component key handling**: UI components that need both rendering and key handling use a component-specific renderer interface plus `IKeyHandler<TContext>` for a component-specific context type. Use `Handle(ConsoleKeyInfo, TContext)`; do not add a shared renderer interface (signatures differ). See [ADR-0042](docs/adr/0042-ui-component-renderer-keyhandler-pattern.md).

28. **Layer state store**: Per-layer animation state is held in a singleton implementing `ITextLayerStateStore<TState>` for each state type. Stateful layers inject the store for their state type (e.g. `ITextLayerStateStore<BeatCirclesState>`) and call `GetState(ctx.LayerIndex)` in Draw. TextLayerDrawContext carries only shared frame data (buffer, snapshot, palette, dimensions, layer index). New stateful layers extend the store (add `ITextLayerStateStore<NewState>` to the implementation and register it); do not add new required properties to TextLayerDrawContext. See [ADR-0043](docs/adr/0043-textlayer-state-store.md).

29. **Layer renderer state type**: Every text layer renderer inherits TextLayerRendererBase and implements `ITextLayerRenderer<TState>` (marker) so the per-layer state type is part of the contract. Stateful layers implement `ITextLayerRenderer<TheirStateType>`; stateless layers implement `ITextLayerRenderer<NoLayerState>`. See [ADR-0044](docs/adr/0044-textlayer-renderer-generic-state-type.md).

30. **Max text layers**: The global maximum number of text layers is 9, defined by `TextLayersLimits.MaxLayerCount` (Domain). Use this constant for layer count limits, padding, defaults, and key bindings 1–9; do not hardcode 9. The value is not user-editable (not in appsettings or settings UI). See [ADR-0045](docs/adr/0045-max-text-layers-constant.md).
